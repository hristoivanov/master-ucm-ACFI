mod TABLA is
  pr CONFIGURATION .
  pr STRING .

  sort Entrada .
  op <_,_> : String Oid -> Entrada [ctor] .
  sort Tabla .
  subsort Entrada < Tabla .
  op nTabla : -> Tabla [ctor] .
  op __ : Tabla Tabla -> Tabla [ctor assoc comm id: nTabla] .

  op insert : Tabla Entrada -> Tabla .
  eq insert(< S, O > T, < S, O' >) = < S, O' > T .
  eq insert(T, < S', O' >) = T < S', O' >  [owise] .

  op delete : Tabla String -> Tabla .
  eq delete(< S, O > T, S) = T .
  eq delete(T, S) = T [owise] .

  vars O O' : Oid .
  vars S S' : String .
  var  E    : Entrada .
  vars T T' : Tabla .

  ***ops auxidle auxactive : -> Oid  .
endm 

***(
red insert( nTabla, < "aa", auxactive > ) .
red insert( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla, < "aa", auxactive > ) .
red insert( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla, < "dd", auxactive > ) .
red insert( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla, < "cc", auxactive > ) .
red insert( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla, < "rr", auxactive > ) .

red delete( nTabla,  "aa" ) .
red delete( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla,  "aa" ) .
red delete( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla,  "dd" ) .
red delete( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla,  "cc" ) .
red delete( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla,  "rr" ) .
)***

load model-checker.maude
load full-maude.maude

(omod RED is
  pr QID .
  pr TABLA .

  subsort Qid < Oid .

  vars O O' O'' O''' : Oid .
  vars B B'     : Object .
  vars S S' S'' : String .
  var  T        : Tabla .
  var  E        : Entrada .
  var  C        : Configuration .
  vars Q Q'     : Qid .
  var Ca        : Cid .
  vars Ats Ats' : AttributeSet .
  vars MSG MSG' : Msg .
  vars lstMsg lstMsg' : listaMsg .
  vars N N' : Nodo .
  var cStr : CjtoString .

  *** 1
  class Proceso | datos : Configuration .

  *** 2, 10, 11
  class Nodo | IP : String, Estado : Mode, recibido : String, amigos : CjtoString .
  sort Mode .
  ops inactivo esperando activo : -> Mode [ctor] .
  op n : Oid -> Oid [ctor] .

  *** 3
  subclass Centro < Nodo .
  class Centro  | tabla : Tabla .

  *** 4
  subclass Extremo < Nodo .
  class Extremo | centro : Oid .
  op null : -> Oid [ctor] .

  *** 5
  class Canal   | origen : Oid, destino : Oid, listaOrigen : listaMsg, listaDestino : listaMsg, estado : EstadoCanal .
  sort listaMsg .
  subsort Msg < listaMsg .
  op nlistaMsg : -> listaMsg [ctor] .
  op _y_ : listaMsg listaMsg -> listaMsg [ctor assoc id: nlistaMsg] .
  sort EstadoCanal .
  ops ok error : -> EstadoCanal [ctor] .

  *** 6 (y pequeña parte del 7)
  msg info : Entrada -> Msg .
  rl [info1] :
     < O : Extremo | Estado : inactivo, IP : S > 
  => < O : Extremo | Estado : esperando >
     info(< S, O >) .
  rl [info2] :
     info(< S, O >)
     < O' : Centro | tabla : T >
  => < O' : Centro | tabla : insert(T, < S, O >), Estado : activo > 
     respuesta-info(O, O') .

  *** 7
  msg respuesta-info : Oid Oid -> Msg .
  rl [respuesta-info1] :
     respuesta-info(O, O')
     < O : Extremo | Estado : esperando >
  => < O : Extremo | Estado : activo, centro : O' > .

  *** 9
  sort CjtoString . 
  subsort String < CjtoString .
  op nCjtoString : -> CjtoString [ctor] .
  op __ : CjtoString CjtoString -> CjtoString [ctor assoc comm id: nCjtoString] .

  *** 12
  msg to_:_ : String String -> Msg .
  
  *** 13
  msg to_:_ : Oid String -> Msg .
  
  *** 14
  *** Orientación canal:  
  ***     Centro   -> siempre es 'destino'
  ***     Extremos -> siempre son el 'origen'
  ***     El 'origen' siempre inserta Msg's en la 'listaOrigen'. Los mensajes de esta lista acaban en el 'destino'.
  ***     El 'destino' siempre inserta Msg's en la 'listaDestino' Los mensajes de esta lista acaban en el 'origen'.
  *** Para el sort 'listaMsg':
  ***     Insertar(MSG, lstMsg) = MSG y lstMsg .
  ***     Extraer(lstMsg y MSG) = lstMsg .

  rl [extremo-canal] : 
     < O  : Proceso | datos : (to S : S') C < n(O) : Extremo | > >
     < O' : Canal | origen : O, listaOrigen : lstMsg, estado : ok >
  => < O  : Proceso | datos : C < n(O) : Extremo | > >
     < O' : Canal | listaOrigen : (to S : S') y lstMsg > .

  rl [canal-extremo] : 
     < O  : Proceso | datos : C < n(O) : Extremo | > >
     < O' : Canal | origen : O, listaDestino : lstMsg y MSG, estado : ok >
  => < O  : Proceso | datos : MSG C < n(O) : Extremo | > >
     < O' : Canal | listaDestino : lstMsg > .

  rl [canal-centro] : 
     < O  : Proceso | datos : C < n(O) : Centro | > >
     < O' : Canal | destino : O, listaOrigen : lstMsg y MSG, estado : ok >
  => < O  : Proceso | datos : MSG C < n(O) : Centro | > >
     < O' : Canal | listaOrigen : lstMsg > .

  rl [centro-canal] : 
     < O  : Proceso | datos : (to n(O'') : S) C < n(O) : Centro | > >
     < O' : Canal | destino : O, origen : O'', listaDestino : lstMsg, estado : ok >
  => < O  : Proceso | datos : C < n(O) : Centro | > >
     < O' : Canal | listaDestino : (to n(O'') : S) y lstMsg > .

  rl [info-extremo-canal] :
     < O  : Proceso | datos : info(< S, n(O) >) C < n(O) : Extremo | > >  
     < O' : Canal | origen : O, listaOrigen : lstMsg, estado : ok >
  => < O  : Proceso | datos : C < n(O) : Extremo | > >
     < O' : Canal | origen : O, listaOrigen : info(< S, n(O) >) y lstMsg, estado : ok > .

  rl [respuesta-info-centro-canal] :
     < O  : Proceso | datos : respuesta-info(n(O''), n(O)) C < n(O) : Centro | > >
     < O' : Canal | destino : O, origen : O'', listaDestino : lstMsg, estado : ok >
  => < O  : Proceso | datos : C < n(O) : Centro | > >
     < O' : Canal | destino : O, listaDestino : respuesta-info(n(O''), n(O)) y lstMsg, estado : ok > .

  *** 15
  ***(
  rl [romper-canal] :
     < O : Canal | estado : ok >
  => < O : Canal | estado : error > . 
  )

  *** 16
  rl [saludar-amigo] :
     < O : Extremo | Estado : activo, amigos : S cStr  > 
  => < O : Extremo | amigos : cStr >
     (to S : "hola") .

  *** 17
  rl [trasformar] :
     (to S : S') 
     < O : Centro | IP : S'', tabla : < S, O' > T, Estado : activo >
  => (to O' : S') 
     < O : Centro | > .

  *** 18
  rl [recibir-centro] : 
     (to S : S')
     < O : Centro | IP : S, Estado : activo, recibido : S'' >
  => < O : Centro | IP : S, Estado : activo, recibido : S'' + S' > .

  rl [recibir-extremo] : 
     (to O : S')
     < O : Extremo | Estado : activo, recibido : S >
  => < O : Extremo | Estado : activo, recibido : S + S' > .

  *** 19
  op numObjetos : Configuration -> Nat .
  eq numObjetos(B C) = 1 + numObjetos(C) .
  eq numObjetos(MSG C) = numObjetos(C) .
  eq numObjetos(C) = 0 [owise] .  

endom)

***8, 20 y 22
(omod EJEMPLO is
  pr CONFIGURATION .
  pr RED .
  vars O O' O'' : Oid .
  var cStr : CjtoString .
  var C C' : Configuration .
  var S : String .

  op ext : Oid String CjtoString -> Object .
  eq ext(O, S, cStr) = < O : Extremo | IP : S, Estado : inactivo, recibido : "", amigos : cStr, centro : null > .

  op cent : Oid String CjtoString -> Object .
  eq cent(O, S, cStr) = < O : Centro | IP : S, Estado : inactivo, recibido : "", amigos : cStr, tabla : nTabla > .

  *** 20
  ops procE procC : Oid String CjtoString -> Object .
  eq procE(O, S, cStr) = < O : Proceso | datos : ext(n(O), S, cStr) > .
  eq procC(O, S, cStr) = < O : Proceso | datos : cent(n(O), S, cStr) > .
 
  op can : Oid Oid Oid -> Object .
  eq can(O, O', O'') = < O : Canal | origen : O', destino : O'', listaOrigen : nlistaMsg, listaDestino : nlistaMsg, estado : ok > .

  op init8 : -> Configuration .
  eq init8 = 
            cent('c0, "ip0", nCjtoString)
            ext('e1, "ip1",  nCjtoString)
            ext('e2, "ip2",  nCjtoString)
            ext('e3, "ip3",  nCjtoString) .

  op init21 : -> Configuration .
  *** Note. Expandir.
  eq init21 = 
             procC('p0, "0000", nCjtoString)
             procE('p1, "1111", "2222")
             procE('p2, "2222", "1111")
             can('c1, 'p1, 'p0)
             can('c2, 'p2, 'p0) .

  op comparaConfs : Configuration Configuration -> Bool .
  eq comparaConfs(C, C') = numObjetos(C) == numObjetos(C') .
endom)

*** 23
(omod PROPS is
  pr SATISFACTION .
  pr EJEMPLO .
  subsort Configuration < State .

  var NUM : Nat .
  vars O O' O'' O''' : Oid .  
  vars S S' : String .
  var N : Nodo .
  vars C C' C'' : Configuration .
  var cStr : CjtoString .
  var lstMsg : listaMsg .
  vars MSG MSG' : Msg .

  op existeNodo : String -> Prop [ctor] .
  eq < O : Proceso | datos : C' < O' : Nodo | IP : S > > C |= existeNodo(S) = true .
  op esAmigoDe : Oid Oid -> Prop [ctor] .
  eq < O : Proceso | datos : C' < O' : Nodo | amigos : S cStr > > < O'' : Proceso | datos : C'' < O''' : Nodo | IP : S > > C |= esAmigoDe(O', O''') = true .       
  op existeMensaje : String -> Prop [ctor] .
  eq < O : Proceso | datos : (to S : S') C' < O' : Centro | > > C |= existeMensaje(S) = true .
  eq < O : Canal | listaOrigen : lstMsg y (to S : S') > C |= existeMensaje(S) = true .
  eq < O : Canal | listaDestino : lstMsg y (to S : S') > C |= existeMensaje(S) = true .

  op numNodos : Configuration -> Nat . 
  eq numNodos(< O : Proceso | datos : < O' : Nodo | > C' > C) = 1 + numNodos(C) .
  eq numNodos(MSG C) = numNodos(C) . 
  eq numNodos(C) = 0 [owise] .

  op numNodosIgualA : Nat -> Prop [ctor] . 
  eq C |= numNodosIgualA( NUM ) = numNodos(C) == NUM .

  op numExtremos : Configuration -> Nat . 
  eq numExtremos(< O : Proceso | datos : < O' : Extremo | > C' > C) = 1 + numExtremos(C) .
  eq numExtremos(MSG C) = numExtremos(C) . 
  eq numExtremos(C) = 0 [owise] .

  op numExtremosIgualA : Nat -> Prop [ctor] . 
  eq C |= numExtremosIgualA( NUM ) = numExtremos(C) == NUM .


  
  op canalEstaBien : Oid -> Prop [ctor] .
  eq < O' : Canal | estado : ok >  C |= canalEstaBien(O') = true .
	
endom)

(omod CHECK is
  pr PROPS .
  pr MODEL-CHECKER .
  pr LTL-SIMPLIFIER .
endom)

(red numObjetos(init21) .)
(frew init21 .)
*** 21
(search init21 =>* C:Configuration s.t. not comparaConfs(init21, C:Configuration) .)

*** 23(a
(red modelCheck(init21, existeNodo("1111")) .)
*** 23(b
(red modelCheck(init21, esAmigoDe( n('p1), n('p2)  )) .)
*** 23(c
(red modelCheck(init21, <> existeMensaje("2222")) .)
*** 23(d
(red modelCheck(init21, numNodosIgualA(3)) .)
*** 23(e
(red modelCheck(init21, numExtremosIgualA(2)) .)
*** 23(f
(red modelCheck(init21, canalEstaBien('c1)) .)

*** 24(a
(red modelCheck(init21, <> numNodosIgualA(3) -> [] numNodosIgualA(3) ) .)
*** La linea superior da True si alguna vez se cumple que numNodosIgualA(x) -> siempre numNodosIgualA(x) 
*** 24(b
(red modelCheck(init21, existeNodo("1111") /\ esAmigoDe(n('p2),n('p1)) -> <> existeMensaje("1111")) .)
*** Mientras la regla de "romper-canal" este comentada un nodo amigo en algun momento tendra un mensaje en la configuracion
*** 24(c
(red modelCheck(init21, []( existeMensaje("1111") -> <> ~ existeMensaje("1111"))   ) .)
*** Si alguna vez existio un mensaje a un nodo quiere decir que en algun momento el mensaje se borrara y desaparecera de mensajes

***(
  Dado nuestro codigo un Nodo Extremo no tiene forma de saber quien ha sido
  el nodo extremo que le ha mandado el mensaje "hola"
  
  Por ejemplo
  Dada la siguiente topologia:
  
  Ext1 |--- canal1 ---|centro|--- canal2 ---| Ext2
  
  Si el Ext1 'saluda' al Ext2 en el centro el mensaje se convertira de un to S : S'
  a un to O : S con lo cual al Ext2 le llega un mensaje con su Oid y "hola". No tiene
  forma de responder (con nuestro codigo) a su amigo.
  
  Seria necesario crear un mensaje de tipo " to S : S' from S'' IDMsg " que
  fuera enviado desde los extremos hacia el centro, de tal forma que S fuera la 
  IP destino, S' el mensaje y S'' la IP origen. De esta forma el nodo central
  tambien tendria que crear un nuevo tipo de mensaje " to O : S from S' " que 
  fuera enviado del centro al extremo cuando recibiera un mensaje "hola" 
  (o cualquier otro mensaje para generalizar) del otro extremo amigo. 
  En este mensaje iria su Oid, el "hola" y la IP del nodo extremo amigo
  que saluda (o que envia cualquier tipo de mensaje).

  Con este nuevo tipo de mensajes se podrian crear unas reglas que:
  
  - Dado el centro y un mensaje de tipo to S : S' from S''
  cree un mensaje mirando en su tabla de ips de tipo to O : S from S' 
  (donde el S'' del primer mensaje fuera igual al S' del segundo)
  Y lo envie hacie el nodo extremo correspondiente.
  
  - Dado un nodo extremo que reciba este tipo de mensaje (to O : S from S')
  Introduzca en el canal que va al centro un mensaje de tipo to S : S' from S''
  (donde el S' del primer mensaje fuera igual al S del segundo e indicase el origen con S'')
  
  De esta forma cualquier nodo extremo respondería a cualquier mensaje que le
  llegara del centro
  
  Además de todo lo anterior para que el Extremo sepa a quien debe responder
  también sería necesario que cada Nodo tengar una tabla 'Tabla de mensaje/saludos enviados'. 
  En la que insertarán al enviar el primer mensaje y de la que borraran al 
  recibir el último mensaje descrito.
  Las entradas de dicha tabla pueden tener este formato: < IP Destino, Mensaje > 
  
  Seria necesario cambiar los mensajes de los extremos por to 'IP Destino' : 'Mensaje' from 'IP Origen' 'ID Mensaje' 
  donde el ID Mensaje: Los extremos tendrán un atributo de tipo Nat.
  Este campo tomará el valor de ese atributo. Después de enviar un
  mensaje de saludo(los mensajes de repuesta no cambiaran el valor)
  ese atributo será incrementado.
  
  Ahora el mensaje del centro seria to 'Oid Destino' : 'Mensaje' from 'IP Origen' 'ID Mensaje'  
  de tal forma que el nodo extremo correspondiente al 'Oid Destino' respondiera con
  to 'IP Destino' : 'Mensaje' 'ID Mensaje' cuyo 'IDMensaje' seria identico al anterior.
  Y el centro volveria a crear un mensaje de tipo to 'Oid Destino' : 'Mensaje' 'ID Mensaje'
  cambiando el Oid.
  
  Con todo esto evitariamos; los bucles infinitos, los saludos multiples, los saludos multiples 
  al mismo nodo y no confundir un saludo por una respuesta de un nodo amigo
)