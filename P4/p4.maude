mod TABLA is
  pr CONFIGURATION .
  pr STRING .

  sort Entrada .
  op <_,_> : String Oid -> Entrada [ctor] .
  sort Tabla .
  subsort Entrada < Tabla .
  op nTabla : -> Tabla [ctor] .
  op __ : Tabla Tabla -> Tabla [ctor assoc comm id: nTabla] .

  op insert : Tabla Entrada -> Tabla .
  eq insert(< S, O > T, < S, O' >) = < S, O' > T .
  eq insert(T, < S', O' >) = T < S', O' >  [owise] .

  op delete : Tabla String -> Tabla .
  eq delete(< S, O > T, S) = T .
  eq delete(T, S) = T [owise] .

  vars O O' : Oid .
  vars S S' : String .
  var  E    : Entrada .
  vars T T' : Tabla .

  ***ops auxidle auxactive : -> Oid  .
endm 

***(
red insert( nTabla, < "aa", auxactive > ) .
red insert( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla, < "aa", auxactive > ) .
red insert( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla, < "dd", auxactive > ) .
red insert( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla, < "cc", auxactive > ) .
red insert( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla, < "rr", auxactive > ) .

red delete( nTabla,  "aa" ) .
red delete( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla,  "aa" ) .
red delete( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla,  "dd" ) .
red delete( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla,  "cc" ) .
red delete( < "aa", auxidle >  < "bb", auxidle > < "cc", auxidle > < "dd", auxidle > nTabla,  "rr" ) .
)***

load model-checker.maude
load full-maude.maude

(omod RED is
  pr QID .
  pr TABLA .

  subsort Qid < Oid .

  vars O O' O'' O''' : Oid .
  vars B B'     : Object .
  vars S S' S'' : String .
  var  T        : Tabla .
  var  E        : Entrada .
  var  C        : Configuration .
  vars Q Q'     : Qid .
  var Ca        : Cid .
  vars Ats Ats' : AttributeSet .
  vars MSG MSG' : Msg .
  vars lstMsg lstMsg' : listaMsg .
  vars N N' : Nodo .
  var cStr : CjtoString .

  *** 1
  class Proceso | datos : Configuration .

  *** 2, 10, 11
  class Nodo | IP : String, Estado : Mode, recibido : String, amigos : CjtoString .
  sort Mode .
  ops inactivo esperando activo : -> Mode [ctor] .
  op n : Oid -> Oid [ctor] .

  *** 3
  subclass Centro < Nodo .
  class Centro  | tabla : Tabla .

  *** 4
  subclass Extremo < Nodo .
  class Extremo | centro : Oid .
  op null : -> Oid [ctor] .

  *** 5
  class Canal   | origen : Oid, destino : Oid, listaOrigen : listaMsg, listaDestino : listaMsg, estado : EstadoCanal .
  sort listaMsg .
  subsort Msg < listaMsg .
  op nlistaMsg : -> listaMsg [ctor] .
  op _y_ : listaMsg listaMsg -> listaMsg [ctor assoc id: nlistaMsg] .
  sort EstadoCanal .
  ops ok error : -> EstadoCanal [ctor] .

  *** 6 (y pequeña parte del 7)
  msg info : Entrada -> Msg .
  rl [info1] :
     < O : Extremo | Estado : inactivo, IP : S > 
  => < O : Extremo | Estado : esperando >
     info(< S, O >) .
  rl [info2] :
     info(< S, O >)
     < O' : Centro | tabla : T >
  => < O' : Centro | tabla : insert(T, < S, O >), Estado : activo > 
     respuesta-info(O, O') .

  *** 7
  msg respuesta-info : Oid Oid -> Msg .
  rl [respuesta-info1] :
     respuesta-info(O, O')
     < O : Extremo | Estado : esperando >
  => < O : Extremo | Estado : activo, centro : O' > .

  *** 9
  sort CjtoString . 
  subsort String < CjtoString .
  op nCjtoString : -> CjtoString [ctor] .
  op __ : CjtoString CjtoString -> CjtoString [ctor assoc comm id: nCjtoString] .

  *** 12
  msg to_:_ : String String -> Msg .
  
  *** 13
  msg to_:_ : Oid String -> Msg .
  
  *** 14
  *** Orientación canal:  
  ***     Centro   -> siempre es 'destino'
  ***     Extremos -> siempre son el 'origen'
  ***     El 'origen' siempre inserta Msg's en la 'listaOrigen'. Los mensajes de esta lista acaban en el 'destino'.
  ***     El 'destino' siempre inserta Msg's en la 'listaDestino' Los mensajes de esta lista acaban en el 'origen'.
  *** Para el sort 'listaMsg':
  ***     Insertar(MSG, lstMsg) = MSG y lstMsg .
  ***     Extraer(lstMsg y MSG) = lstMsg .

  rl [extremo-canal] : 
     < O  : Proceso | datos : (to S : S') C < n(O) : Extremo | > >
     < O' : Canal | origen : O, listaOrigen : lstMsg, estado : ok >
  => < O  : Proceso | datos : C < n(O) : Extremo | > >
     < O' : Canal | listaOrigen : (to S : S') y lstMsg > .

  rl [canal-extremo] : 
     < O  : Proceso | datos : C < n(O) : Extremo | > >
     < O' : Canal | origen : O, listaDestino : lstMsg y MSG, estado : ok >
  => < O  : Proceso | datos : MSG C < n(O) : Extremo | > >
     < O' : Canal | listaDestino : lstMsg > .

  rl [canal-centro] : 
     < O  : Proceso | datos : C < n(O) : Centro | > >
     < O' : Canal | destino : O, listaOrigen : lstMsg y MSG, estado : ok >
  => < O  : Proceso | datos : MSG C < n(O) : Centro | > >
     < O' : Canal | listaOrigen : lstMsg > .

  rl [centro-canal] : 
     < O  : Proceso | datos : (to n(O'') : S) C < n(O) : Centro | > >
     < O' : Canal | destino : O, origen : O'', listaDestino : lstMsg, estado : ok >
  => < O  : Proceso | datos : C < n(O) : Centro | > >
     < O' : Canal | listaDestino : (to n(O'') : S) y lstMsg > .

  rl [info-extremo-canal] :
     < O  : Proceso | datos : info(< S, n(O) >) C < n(O) : Extremo | > >  
     < O' : Canal | origen : O, listaOrigen : lstMsg, estado : ok >
  => < O  : Proceso | datos : C < n(O) : Extremo | > >
     < O' : Canal | origen : O, listaOrigen : info(< S, n(O) >) y lstMsg, estado : ok > .

  rl [respuesta-info-centro-canal] :
     < O  : Proceso | datos : respuesta-info(n(O''), n(O)) C < n(O) : Centro | > >
     < O' : Canal | destino : O, origen : O'', listaDestino : lstMsg, estado : ok >
  => < O  : Proceso | datos : C < n(O) : Centro | > >
     < O' : Canal | destino : O, listaDestino : respuesta-info(n(O''), n(O)) y lstMsg, estado : ok > .

  *** 15

  rl [romper-canal] :
     < O : Canal | estado : ok >
  => < O : Canal | estado : error > .
  ***(
  )

  *** 16
  rl [saludar-amigo] :
     < O : Extremo | Estado : activo, amigos : S cStr  > 
  => < O : Extremo | amigos : cStr >
     (to S : "hola") .

  *** 17
  rl [trasformar] :
     (to S : S') 
     < O : Centro | IP : S'', tabla : < S, O' > T, Estado : activo >
  => (to O' : S') 
     < O : Centro | > .

  *** 18
  rl [recibir-centro] : 
     (to S : S')
     < O : Centro | IP : S, Estado : activo, recibido : S'' >
  => < O : Centro | IP : S, Estado : activo, recibido : S'' + S' > .

  rl [recibir-extremo] : 
     (to O : S')
     < O : Extremo | Estado : activo, recibido : S >
  => < O : Extremo | Estado : activo, recibido : S + S' > .

  *** 19
  op numObjetos : Configuration -> Nat .
  eq numObjetos(B C) = 1 + numObjetos(C) .
  eq numObjetos(MSG C) = numObjetos(C) .
  eq numObjetos(C) = 0 [owise] .  

  *** 20 y 21
 


  ***(
  class Nodo    | IP : String, Estado : Mode, recibido : String, amigos : CjtoString .
  class Extremo | centro : Oid . 
  class Centro  | tabla : Tabla .

  rl [info1] :
     < O : Extremo | Estado : inactivo, IP : S > 
  => < O : Extremo | Estado : esperando >
     info(< S, O >) .
  rl [info2] :
     info(< S, O >)
     < O' : Centro | tabla : T >
  => < O' : Centro | tabla : insert(T, < S, O >), Estado : activo > 
     respuesta-info(O, O') .
  )  


endom)


***8 y 21 y 22
(omod EJEMPLO is
  pr CONFIGURATION .
  pr RED .
  vars O O' O'' : Oid .
  var cStr : CjtoString .
  var C C' : Configuration .
  var S : String .

  op ext : Oid String CjtoString -> Object .
  eq ext(O, S, cStr) = < O : Extremo | IP : S, Estado : inactivo, recibido : "", amigos : cStr, centro : null > .

  op cent : Oid String CjtoString -> Object .
  eq cent(O, S, cStr) = < O : Centro | IP : S, Estado : inactivo, recibido : "", amigos : cStr, tabla : nTabla > .

  ops procE procC : Oid String CjtoString -> Object .
  eq procE(O, S, cStr) = < O : Proceso | datos : ext(n(O), S, cStr) > .
  eq procC(O, S, cStr) = < O : Proceso | datos : cent(n(O), S, cStr) > .
 
  op can : Oid Oid Oid -> Object .
  eq can(O, O', O'') = < O : Canal | origen : O', destino : O'', listaOrigen : nlistaMsg, listaDestino : nlistaMsg, estado : ok > .

  op init8 : -> Configuration .
  eq init8 = 
            cent('c0, "ip0", nCjtoString)
            ext('e1, "ip1",  nCjtoString)
            ext('e2, "ip2",  nCjtoString)
            ext('e3, "ip3",  nCjtoString) .

  op init21 : -> Configuration .
  *** Note. Expandir.
  eq init21 = 
             procC('p0, "0000", nCjtoString)
             procE('p1, "1111", "2222")
             procE('p2, "2222", "1111")
             can('c1, 'p1, 'p0)
             can('c2, 'p2, 'p0) .

  op comparaConfs : Configuration Configuration -> Bool .
  eq comparaConfs(C, C') = numObjetos(C) == numObjetos(C') .
endom)

*** 23
(omod PROPS is
  pr SATISFACTION .
  pr EJEMPLO .
  subsort Configuration < State .

  var NUM : Nat .
  vars O O' O'' O''' : Oid .  
  vars S S' : String .
  var N : Nodo .
  vars C C' C'' : Configuration .
  var cStr : CjtoString .
  var lstMsg : listaMsg .
  vars MSG MSG' : Msg .

  op existeNodo : String -> Prop [ctor] .
  eq < O : Proceso | datos : C' < O' : Nodo | IP : S > > C |= existeNodo(S) = true .
  op esAmigoDe : Oid Oid -> Prop [ctor] .
  eq < O : Proceso | datos : C' < O' : Nodo | amigos : S cStr > > < O'' : Proceso | datos : C'' < O''' : Nodo | IP : S > > C |= esAmigoDe(O', O''') = true .       
  op existeMensaje : String -> Prop [ctor] .
  eq < O : Proceso | datos : (to S : S') C' < O' : Centro | > > C |= existeMensaje(S) = true .
  eq < O : Canal | listaOrigen : lstMsg y (to S : S') > C |= existeMensaje(S) = true .
  eq < O : Canal | listaDestino : lstMsg y (to S : S') > C |= existeMensaje(S) = true .

  op numNodos : Configuration -> Nat . 
  eq numNodos(< O : Proceso | datos : < O' : Nodo | > C' > C) = 1 + numNodos(C) .
  eq numNodos(MSG C) = numNodos(C) . 
  eq numNodos(C) = 0 [owise] .

  op numNodosIgualA : Nat -> Prop [ctor] . 
  eq C |= numNodosIgualA( NUM ) = numNodos(C) == NUM .

  op numExtremos : Configuration -> Nat . 
  eq numExtremos(< O : Proceso | datos : < O' : Extremo | > C' > C) = 1 + numExtremos(C) .
  eq numExtremos(MSG C) = numExtremos(C) . 
  eq numExtremos(C) = 0 [owise] .

  op numExtremosIgualA : Nat -> Prop [ctor] . 
  eq C |= numExtremosIgualA( NUM ) = numExtremos(C) == NUM .


  
  op canalEstaBien : Oid -> Prop [ctor] .
  eq < O' : Canal | estado : ok >  C |= canalEstaBien(O') = true .
	
endom)

(omod CHECK is
  pr PROPS .
  pr MODEL-CHECKER .
  pr LTL-SIMPLIFIER .
endom)

(red numObjetos(init21) .)
(frew init21 .)
(search init21 =>* C:Configuration s.t. not comparaConfs(init21, C:Configuration) .)

*** 23(a
(red modelCheck(init21, existeNodo("1111")) .)
*** 23(b
(red modelCheck(init21, esAmigoDe( n('p1), n('p2)  )) .)
*** 23(c
(red modelCheck(init21, <> existeMensaje("2222")) .)
*** 23(d
(red modelCheck(init21, numNodosIgualA(3)) .)
*** 23(e
(red modelCheck(init21, numExtremosIgualA(2)) .)
*** 23(f
(red modelCheck(init21, canalEstaBien('c1)) .)

*** 24(a
(red modelCheck(init21, <> numNodosIgualA(3) -> [] numNodosIgualA(3) ) .)
*** La linea superior da True si alguna vez se cumple que numNodosIgualA(x) -> siempre numNodosIgualA(x) 
*** 24(b
(red modelCheck(init21, existeNodo("1111") /\ esAmigoDe(n('p2),n('p1)) -> <> existeMensaje("1111")) .)
*** Mientras la regla de "romper-canal" este comentada un nodo amigo en algun momento tendra un mensaje en la configuracion
*** 24(c
(red modelCheck(init21, []( existeMensaje("1111") -> <> ~ existeMensaje("1111"))   ) .)
*** Si alguna vez existio un mensaje a un nodo quiere decir que en algun momento el mensaje se borrara y desaparecera de mensajes
